

# ============================================
# 9) AVALIAÇÃO FORA-DA-AMOSTRA (SPLIT 50/50)
# ============================================
SPLIT_FRAC = 0.5
DEC = DECIMALS_TABLES

Y_full = yields_monthly.astype(float).copy()
Y_full = Y_full.loc[yields_m.index]  # garante alinhamento

T_full = len(Y_full.index)
split_idx = int(np.floor(SPLIT_FRAC * T_full))
split_idx = max(split_idx, 24)
split_idx = min(split_idx, T_full - 12)

train_month_idx = Y_full.index[:split_idx]
test_month_idx  = Y_full.index[split_idx:]

test_start = test_month_idx[0]
train_fx_idx = r_xs.index[r_xs.index < test_start]
test_fx_idx  = r_xs.index[r_xs.index >= test_start]
N_test = len(test_fx_idx)
if N_test < 24:
    raise ValueError("Teste OOS ficou curto demais. Ajuste SPLIT_FRAC ou verifique amostra.")

# -------- PCA OOS: estima na 1ª metade e aplica na 2ª --------
Y_train = Y_full.loc[train_month_idx].values
Y_mean = Y_train.mean(axis=0)

pca_oos = PCA(n_components=5)
pca_oos.fit(Y_train - Y_mean)

PC_full = pd.DataFrame(
    pca_oos.transform(Y_full.values - Y_mean),
    index=Y_full.index,
    columns=[f"PC{i}" for i in range(1, 6)]
)

# PCs alinhados ao índice de r_xs (T-1)
PC_ini = PC_full.loc[r_xs.index].copy()  # (T-1) x 5

# ============================================
# 10) ERROS DE PREVISÃO (OOS): RW, HE, PC5, ADRIAN
# ============================================

# -------- HE: previsão E[r_xs]=0 => erro = r_xs --------
err_he = r_xs.loc[test_fx_idx, mats_cols_tables].copy()

# -------- RW: previsão r_{t+1} = r_t --------
pos0 = r_xs.index.get_loc(test_fx_idx[0])
if pos0 < 1:
    raise ValueError("Não existe observação anterior para iniciar RW no teste.")

rw_fore = r_xs.iloc[pos0-1 : pos0-1 + N_test, :][mats_cols_tables].values
rw_real = r_xs.loc[test_fx_idx, mats_cols_tables].values
err_rw = pd.DataFrame(rw_real - rw_fore, index=test_fx_idx, columns=mats_cols_tables)

# -------- PC5 (MQO irrestrito): estima no treino, prevê no teste --------
X_train = add_const(PC_ini.loc[train_fx_idx].values.astype(float))
X_test  = add_const(PC_ini.loc[test_fx_idx].values.astype(float))

err_pc5 = pd.DataFrame(index=test_fx_idx, columns=mats_cols_tables, dtype=float)
for col in mats_cols_tables:
    ytr = r_xs.loc[train_fx_idx, col].values.astype(float)
    msk = np.isfinite(ytr) & np.all(np.isfinite(X_train), axis=1)
    res = sm.OLS(ytr[msk], X_train[msk, :]).fit()
    yhat = X_test @ res.params
    ytrue = r_xs.loc[test_fx_idx, col].values.astype(float)
    err_pc5[col] = ytrue - yhat

# -------- Adrian 3 steps (OOS): Step 2 com choques VAR + PCs --------
# Step 1: VAR(1) nos PCs (treino)
pc_train = PC_full.loc[train_month_idx].values.astype(float)
var_model = VAR(pc_train)
var1 = var_model.fit(1, trend="c")

c_vec = var1.params[0, :]       # (5,)
A_mat = var1.coefs[0, :, :]     # (5x5)

# choques v_t no período todo (a partir do 2º mês)
Vhat = np.full_like(PC_full.values, np.nan)
pc_all = PC_full.values.astype(float)
for t in range(1, len(PC_full.index)):
    Vhat[t, :] = pc_all[t, :] - (c_vec + A_mat @ pc_all[t-1, :])

Vhat_df = pd.DataFrame(Vhat, index=PC_full.index, columns=[f"V{i}" for i in range(1, 6)])
Vhat_fx = Vhat_df.loc[r_xs.index].copy()  # alinha com retornos (T-1 x 5)

# Sigma_hat (treino)
Vhat_train_fx = Vhat_fx.loc[train_fx_idx].values.astype(float)
Vhat_train_fx = Vhat_train_fx[np.all(np.isfinite(Vhat_train_fx), axis=1)]
Sigma_hat = (Vhat_train_fx.T @ Vhat_train_fx) / max((Vhat_train_fx.shape[0] - 6), 1)

# Step 1b: U_hat via yields_m ~ PCs (treino), residual aplicado no período todo
Uy = np.zeros_like(yields_m.values.astype(float))
Xy_train = add_const(PC_full.loc[train_month_idx].values.astype(float))
Xy_all   = add_const(PC_full.values.astype(float))

for j in range(yields_m.shape[1]):
    yj_train = yields_m.loc[train_month_idx].iloc[:, j].values.astype(float)
    msk = np.isfinite(yj_train) & np.all(np.isfinite(Xy_train), axis=1)
    res = sm.OLS(yj_train[msk], Xy_train[msk, :]).fit()
    Uy[:, j] = yields_m.iloc[:, j].values.astype(float) - (Xy_all @ res.params)

U_ini = Uy[0:T-1, 1:H]  # (T-1)x(H-1), colunas M2..MH
U_ini_df = pd.DataFrame(U_ini, index=r_xs.index, columns=r_xs.columns)

# Step 2: r_xs ~ [Vhat, PCs] (treino)
Z_train = np.hstack([Vhat_fx.loc[train_fx_idx].values.astype(float),
                     PC_ini.loc[train_fx_idx].values.astype(float)])
Z_test  = np.hstack([Vhat_fx.loc[test_fx_idx].values.astype(float),
                     PC_ini.loc[test_fx_idx].values.astype(float)])
Zc_train = add_const(Z_train)
Zc_test  = add_const(Z_test)

H_minus1 = r_xs.shape[1]
a_hat_A = np.zeros(H_minus1)
beta_hat_A = np.zeros((5, H_minus1))
c_hat_A = np.zeros((5, H_minus1))
Ehat_train = np.full((len(train_fx_idx), H_minus1), np.nan)

for j, col in enumerate(r_xs.columns):
    ytr = r_xs.loc[train_fx_idx, col].values.astype(float)
    msk = np.isfinite(ytr) & np.all(np.isfinite(Zc_train), axis=1)
    res = sm.OLS(ytr[msk], Zc_train[msk, :]).fit()

    a_hat_A[j] = res.params[0]
    beta_hat_A[:, j] = res.params[1:6]     # V1..V5
    c_hat_A[:, j]    = res.params[6:11]    # PC1..PC5

    tmp = np.full(len(train_fx_idx), np.nan)
    tmp[msk] = res.resid
    Ehat_train[:, j] = tmp

sig2_hat = np.nanmean(Ehat_train**2)

def vec_outer(b):
    return np.outer(b, b).reshape(-1, order="F")

B_ast = np.column_stack([vec_outer(beta_hat_A[:, i]) for i in range(H_minus1)])  # 25 x (H-1)
vec_Sigma = Sigma_hat.reshape(-1, order="F").reshape(-1, 1)
B_ast_vecSigma = (B_ast.T @ vec_Sigma).reshape(-1)

idx0_sel_adrian = [m - 1 for m in mats_tables if (m - 1) < H_minus1]
if len(idx0_sel_adrian) >= 3:
    B = beta_hat_A[:, idx0_sel_adrian].T
    C = c_hat_A[:, idx0_sel_adrian].T
    Lambda_hat = np.linalg.solve(B.T @ B, B.T @ C)
else:
    Lambda_hat = np.zeros((5, 5))

term = a_hat_A + (B_ast_vecSigma + sig2_hat) / 2.0
term_vec = term.reshape(-1, 1)

betabeta_inv = np.linalg.pinv(beta_hat_A @ beta_hat_A.T)
lambda_hat = betabeta_inv @ (beta_hat_A @ term_vec)  # 5x1

t_beta_lambda = (beta_hat_A.T @ lambda_hat).reshape(1, -1)  # 1 x (H-1)
kappa_hat = t_beta_lambda - ((B_ast_vecSigma + sig2_hat) / 2.0).reshape(1, -1)
Kappa_hat_T = (Lambda_hat.T @ beta_hat_A)  # 5 x (H-1)

# previsão Adrian no teste:
Xtest_pc = PC_ini.loc[test_fx_idx].values.astype(float)   # (N_test x 5)
E_adrian_test = (np.ones((N_test, 1)) @ kappa_hat) + (Xtest_pc @ Kappa_hat_T) + U_ini_df.loc[test_fx_idx].values
ytrue_test_all = r_xs.loc[test_fx_idx].values.astype(float)

err_adrian_all = ytrue_test_all - E_adrian_test
err_adrian_all_df = pd.DataFrame(err_adrian_all, index=test_fx_idx, columns=r_xs.columns)
err_adrian = err_adrian_all_df[mats_cols_tables].copy()








# ============================================
# 12) GRÁFICOS (mensais) no PERÍODO DE TESTE:
# 1) yield prevista vs realizada
# 2) r_xs prevista vs realizada
# ============================================

# escolha do vencimento
MAT_YIELD_PLOT = "M24"
MAT_RXS_PLOT   = "M24"
MODEL_RXS = "pc5"  # "pc5", "adrian" ou "he"

if MAT_YIELD_PLOT not in yields_monthly.columns:
    raise ValueError(f"{MAT_YIELD_PLOT} não está em yields_monthly.columns")
if MAT_RXS_PLOT not in r_xs.columns:
    raise ValueError(f"{MAT_RXS_PLOT} não está em r_xs.columns")

# índices de teste
test_month_idx = yields_monthly.index[yields_monthly.index >= test_start]
train_month_idx = yields_monthly.index[yields_monthly.index < test_start]

# 12.1 Yield prevista vs realizada (modelo: yield = a + b'PC)
PC_month = PC_full.loc[yields_monthly.index].copy()
Xy_train = add_const(PC_month.loc[train_month_idx].values.astype(float))
Xy_test  = add_const(PC_month.loc[test_month_idx].values.astype(float))

y_train = yields_monthly.loc[train_month_idx, MAT_YIELD_PLOT].values.astype(float)
msk = np.isfinite(y_train) & np.all(np.isfinite(Xy_train), axis=1)
res_y = sm.OLS(y_train[msk], Xy_train[msk, :]).fit()

yhat_test = Xy_test @ res_y.params
ytrue_test = yields_monthly.loc[test_month_idx, MAT_YIELD_PLOT].values.astype(float)

fig, ax = plt.subplots(figsize=(8.5, 4.8))
ax.plot(test_month_idx, ytrue_test, label="Realizada")
ax.plot(test_month_idx, yhat_test, label="Prevista")
ax.set_xlabel("Ano")
ax.set_ylabel("Yield (% a.a.)")
ax.legend(loc="upper left", frameon=False)
save_fig_pdf(fig, f"yield_prevista_vs_realizada_{MAT_YIELD_PLOT}.pdf")

# 12.2 r_xs previsto vs realizado
PC_fx = PC_ini.copy()
Xr_train = add_const(PC_fx.loc[train_fx_idx].values.astype(float))
Xr_test  = add_const(PC_fx.loc[test_fx_idx].values.astype(float))

ytr = r_xs.loc[train_fx_idx, MAT_RXS_PLOT].values.astype(float)
msk = np.isfinite(ytr) & np.all(np.isfinite(Xr_train), axis=1)

if MODEL_RXS == "he":
    rhat_test = np.zeros(len(test_fx_idx), dtype=float)
elif MODEL_RXS == "pc5":
    res_r = sm.OLS(ytr[msk], Xr_train[msk, :]).fit()
    rhat_test = Xr_test @ res_r.params
elif MODEL_RXS == "adrian":
    # previsão = realizada - erro (já temos err_adrian_all_df no OOS)
    rhat_test = (r_xs.loc[test_fx_idx, MAT_RXS_PLOT] - err_adrian_all_df.loc[test_fx_idx, MAT_RXS_PLOT]).values
else:
    raise ValueError("MODEL_RXS deve ser 'pc5', 'adrian' ou 'he'.")

rtrue_test = r_xs.loc[test_fx_idx, MAT_RXS_PLOT].values.astype(float)

fig, ax = plt.subplots(figsize=(8.5, 4.8))
ax.plot(test_fx_idx, rtrue_test * 100, label="Realizado")
ax.plot(test_fx_idx, rhat_test * 100, label="Previsto")
ax.set_xlabel("Ano")
ax.set_ylabel("Retorno em excesso (p.p.)")
ax.legend(loc="upper left", frameon=False)
save_fig_pdf(fig, f"rxs_previsto_vs_realizado_{MODEL_RXS}_{MAT_RXS_PLOT}.pdf")

print("OK: tabelas e gráficos gerados.")

# ============================================
# 13) RESUMO
# ============================================
print("\n==== SAÍDAS GERADAS ====")
print("Figuras (PDF):", FIG_DIR)
print("Tabelas (LaTeX .tex):", TAB_DIR)
print("\nDica Overleaf (pacotes):")
print(r"- \usepackage{booktabs}")
print(r"- \usepackage{graphicx}")
print(r"- \usepackage{ragged2e}  % para \justifying nas notas")
print("\nDica Overleaf (inclusão):")
print(r"- \includegraphics{figuras/selected_yields_monthly.pdf}")
print(r"- \input{tabelas/MSPE_ratio_all_vs_RW_oos.tex}")
